from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from azure.cosmos import CosmosClient
import jwt
import os
import logging
import uuid

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="listings-svc")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://salmon-ocean-0f0f87203.3.azurestaticapps.net", "http://localhost:3000", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

COSMOS_URI = os.getenv("COSMOS_URI")
COSMOS_KEY = os.getenv("COSMOS_KEY")
COSMOS_DB = os.getenv("COSMOS_DB", "appdata")
COSMOS_CONTAINER = os.getenv("COSMOS_CONTAINER", "chat")
JWT_SECRET = os.getenv("JWT_SECRET", "dev-secret")

cosmos_client = None
container = None

if COSMOS_URI and COSMOS_KEY:
    try:
        cosmos_client = CosmosClient(COSMOS_URI, credential=COSMOS_KEY)
        db = cosmos_client.get_database_client(COSMOS_DB)
        container = db.get_container_client(COSMOS_CONTAINER)
        logger.info(f"Cosmos DB initialized: {COSMOS_DB}/{COSMOS_CONTAINER}")
    except Exception as e:
        logger.error(f"Failed to initialize Cosmos: {e}")

class ListingCreate(BaseModel):
    title: str
    category: Optional[str] = ""
    description: Optional[str] = ""
    price: float
    visibility: Optional[str] = "public"

class ListingUpdate(BaseModel):
    title: Optional[str] = None
    category: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None
    visibility: Optional[str] = None

def get_user_from_token(authorization: str = Header(None)):
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(401, "Missing or invalid authorization header")
    token = authorization.replace("Bearer ", "")
    try:
        data = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
        return data["sub"]
    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(401, "Invalid token")

# ==================== LISTINGS ====================

@app.get("/listings")
def get_listings():
    if not container:
        return []
    try:
        query = "SELECT * FROM c WHERE c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        return items
    except Exception as e:
        logger.error(f"Error: {e}")
        return []

@app.get("/listings/my")
def get_my_listings(email: str = Depends(get_user_from_token)):
    if not container:
        return []
    try:
        query = "SELECT * FROM c WHERE c.type = 'listing' AND c.seller = @email"
        items = list(container.query_items(
            query=query,
            parameters=[{"name": "@email", "value": email}],
            enable_cross_partition_query=True
        ))
        return items
    except Exception as e:
        logger.error(f"Error: {e}")
        return []

@app.post("/listings")
def create_listing(listing: ListingCreate, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        listing_id = str(uuid.uuid4())
        doc = {
            "id": listing_id,
            "roomId": listing_id,  # Partition key for Cosmos DB
            "type": "listing",
            "title": listing.title,
            "category": listing.category or "",
            "description": listing.description or "",
            "price": float(listing.price),
            "seller": email,
            "status": "active",
            "visibility": listing.visibility or "public",
            "createdAt": datetime.utcnow().isoformat()
        }
        container.create_item(doc)
        logger.info(f"Created listing {listing_id}")
        return doc
    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(500, str(e))

@app.put("/listings/{listing_id}")
def update_listing(listing_id: str, updates: ListingUpdate, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        query = f"SELECT * FROM c WHERE c.id = '{listing_id}' AND c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        
        if not items:
            raise HTTPException(404, "Listing not found")
        
        listing = items[0]
        
        if listing.get("seller") != email:
            raise HTTPException(403, "You can only edit your own listings")
        
        if updates.title is not None:
            listing["title"] = updates.title
        if updates.category is not None:
            listing["category"] = updates.category
        if updates.description is not None:
            listing["description"] = updates.description
        if updates.price is not None:
            listing["price"] = float(updates.price)
        if updates.visibility is not None:
            listing["visibility"] = updates.visibility
        
        listing["updatedAt"] = datetime.utcnow().isoformat()
        
        container.replace_item(item=listing["id"], body=listing)
        logger.info(f"Updated listing {listing_id}")
        return listing
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(500, str(e))

@app.delete("/listings/{listing_id}")
def delete_listing(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        # Get existing listing first
        query = f"SELECT * FROM c WHERE c.id = '{listing_id}' AND c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        
        if not items:
            raise HTTPException(404, "Listing not found")
        
        listing = items[0]
        
        # Check ownership
        if listing.get("seller") != email:
            raise HTTPException(403, "You can only delete your own listings")
        
        # Delete using roomId as partition key (Cosmos DB requirement)
        partition_key = listing.get("roomId", listing_id)
        container.delete_item(item=listing_id, partition_key=partition_key)
        logger.info(f"Deleted listing {listing_id}")
        return {"status": "deleted", "id": listing_id}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Delete error: {e}")
        raise HTTPException(500, f"Delete failed: {str(e)}")

@app.post("/listings/{listing_id}/buy")
def buy_listing(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        # Get the listing
        query = f"SELECT * FROM c WHERE c.id = '{listing_id}' AND c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        
        if not items:
            raise HTTPException(404, "Listing not found")
        
        listing = items[0]
        
        # Check if already sold
        if listing.get("status") == "sold":
            raise HTTPException(400, "This item has already been sold")
        
        # Check if trying to buy own listing
        if listing.get("seller") == email:
            raise HTTPException(400, "You cannot buy your own listing")
        
        # Update listing to sold
        listing["status"] = "sold"
        listing["buyer"] = email
        listing["soldAt"] = datetime.utcnow().isoformat()
        listing["updatedAt"] = datetime.utcnow().isoformat()
        
        container.replace_item(item=listing["id"], body=listing)
        
        # Create a chat room between buyer and seller
        chat_room_id = str(uuid.uuid4())
        chat_room = {
            "id": chat_room_id,
            "roomId": chat_room_id,  # Partition key
            "type": "chat_room",
            "listingId": listing_id,
            "listingTitle": listing.get("title"),
            "buyer": email,
            "seller": listing.get("seller"),
            "createdAt": datetime.utcnow().isoformat(),
            "lastMessageAt": datetime.utcnow().isoformat()
        }
        container.create_item(chat_room)
        
        # Create automated welcome message in the chat
        message_id = str(uuid.uuid4())
        message_doc = {
            "id": message_id,
            "roomId": chat_room_id,  # Partition key - same as chat room
            "type": "chat_message",
            "chatRoomId": chat_room_id,
            "from": "system",
            "to": listing.get("seller"),
            "message": f"ðŸŽ‰ Great news! {email} just purchased '{listing.get('title')}' for â‚¬{listing.get('price'):.2f}.\n\nUse this chat to arrange payment and delivery. Both buyer and seller can send messages here.",
            "createdAt": datetime.utcnow().isoformat()
        }
        container.create_item(message_doc)
        
        logger.info(f"Listing {listing_id} sold to {email}, chat room {chat_room_id} created")
        return {
            "status": "success",
            "message": "Purchase completed! Chat room created.",
            "listing": listing,
            "chatRoomId": chat_room_id
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Buy error: {e}")
        raise HTTPException(500, f"Purchase failed: {str(e)}")

# ==================== CHAT ROOMS ====================

@app.get("/chat/rooms")
def get_chat_rooms(email: str = Depends(get_user_from_token)):
    if not container:
        return []
    try:
        # Get all chat rooms where user is buyer or seller
        query = """
        SELECT * FROM c 
        WHERE c.type = 'chat_room' 
        AND (c.buyer = @email OR c.seller = @email)
        ORDER BY c.lastMessageAt DESC
        """
        items = list(container.query_items(
            query=query,
            parameters=[{"name": "@email", "value": email}],
            enable_cross_partition_query=True
        ))
        return items
    except Exception as e:
        logger.error(f"Error fetching chat rooms: {e}")
        return []

@app.get("/chat/rooms/{room_id}/messages")
def get_chat_messages(room_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        return []
    try:
        # Verify user is part of this chat
        room_query = f"SELECT * FROM c WHERE c.id = '{room_id}' AND c.type = 'chat_room'"
        rooms = list(container.query_items(query=room_query, enable_cross_partition_query=True))
        
        if not rooms:
            raise HTTPException(404, "Chat room not found")
        
        room = rooms[0]
        if room.get("buyer") != email and room.get("seller") != email:
            raise HTTPException(403, "You are not part of this chat")
        
        # Get messages for this room
        query = f"SELECT * FROM c WHERE c.type = 'chat_message' AND c.chatRoomId = '{room_id}' ORDER BY c.createdAt ASC"
        messages = list(container.query_items(query=query, enable_cross_partition_query=True))
        
        return messages
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching messages: {e}")
        return []

@app.post("/chat/rooms/{room_id}/messages")
def send_chat_message(room_id: str, message: dict, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        # Verify user is part of this chat
        room_query = f"SELECT * FROM c WHERE c.id = '{room_id}' AND c.type = 'chat_room'"
        rooms = list(container.query_items(query=room_query, enable_cross_partition_query=True))
        
        if not rooms:
            raise HTTPException(404, "Chat room not found")
        
        room = rooms[0]
        if room.get("buyer") != email and room.get("seller") != email:
            raise HTTPException(403, "You are not part of this chat")
        
        # Determine recipient
        recipient = room.get("seller") if email == room.get("buyer") else room.get("buyer")
        
        # Create message
        message_id = str(uuid.uuid4())
        message_doc = {
            "id": message_id,
            "roomId": room_id,  # Partition key
            "type": "chat_message",
            "chatRoomId": room_id,
            "from": email,
            "to": recipient,
            "message": message.get("text", ""),
            "createdAt": datetime.utcnow().isoformat()
        }
        container.create_item(message_doc)
        
        # Update room's last message time
        room["lastMessageAt"] = datetime.utcnow().isoformat()
        container.replace_item(item=room["id"], body=room)
        
        logger.info(f"Message sent in room {room_id} from {email}")
        return {"status": "sent", "message": message_doc}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Send message error: {e}")
        raise HTTPException(500, f"Failed to send message: {str(e)}")

# ==================== FAVOURITES ====================

@app.get("/favourites")
def get_favourites(email: str = Depends(get_user_from_token)):
    if not container:
        return []
    try:
        query = "SELECT * FROM c WHERE c.type = 'favourite' AND c.userId = @email"
        items = list(container.query_items(
            query=query,
            parameters=[{"name": "@email", "value": email}],
            enable_cross_partition_query=True
        ))
        return [item["listingId"] for item in items]
    except Exception as e:
        logger.error(f"Error: {e}")
        return []

@app.post("/favourites/{listing_id}")
def add_favourite(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        fav_id = f"fav:{email}:{listing_id}"
        doc = {
            "id": fav_id,
            "roomId": fav_id,  # Partition key for Cosmos DB
            "type": "favourite",
            "userId": email,
            "listingId": listing_id,
            "createdAt": datetime.utcnow().isoformat()
        }
        container.upsert_item(doc)
        return {"status": "added"}
    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(500, str(e))

@app.delete("/favourites/{listing_id}")
def remove_favourite(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        fav_id = f"fav:{email}:{listing_id}"
        # Use fav_id as partition key since roomId = fav_id
        container.delete_item(item=fav_id, partition_key=fav_id)
        return {"status": "removed"}
    except Exception as e:
        logger.error(f"Error removing favourite: {e}")
        return {"status": "removed"}

@app.get("/healthz")
def health():
    return {"status": "healthy", "service": "listings-svc"}

@app.get("/")
def root():
    return {"service": "listings-svc"}

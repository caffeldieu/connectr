from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime
from azure.cosmos import CosmosClient
import jwt
import os
import logging
import uuid

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(title="listings-svc")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://salmon-ocean-0f0f87203.3.azurestaticapps.net", "http://localhost:3000", "http://localhost:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

COSMOS_URI = os.getenv("COSMOS_URI")
COSMOS_KEY = os.getenv("COSMOS_KEY")
COSMOS_DB = os.getenv("COSMOS_DB", "appdata")
COSMOS_CONTAINER = os.getenv("COSMOS_CONTAINER", "chat")
JWT_SECRET = os.getenv("JWT_SECRET", "dev-secret")

cosmos_client = None
container = None

if COSMOS_URI and COSMOS_KEY:
    try:
        cosmos_client = CosmosClient(COSMOS_URI, credential=COSMOS_KEY)
        db = cosmos_client.get_database_client(COSMOS_DB)
        container = db.get_container_client(COSMOS_CONTAINER)
        logger.info(f"Cosmos DB initialized: {COSMOS_DB}/{COSMOS_CONTAINER}")
    except Exception as e:
        logger.error(f"Failed to initialize Cosmos: {e}")

class ListingCreate(BaseModel):
    title: str
    category: Optional[str] = ""
    description: Optional[str] = ""
    price: float
    visibility: Optional[str] = "public"

class ListingUpdate(BaseModel):
    title: Optional[str] = None
    category: Optional[str] = None
    description: Optional[str] = None
    price: Optional[float] = None
    visibility: Optional[str] = None

def get_user_from_token(authorization: str = Header(None)):
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(401, "Missing or invalid authorization header")
    token = authorization.replace("Bearer ", "")
    try:
        data = jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
        return data["sub"]
    except jwt.ExpiredSignatureError:
        raise HTTPException(401, "Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(401, "Invalid token")

# ==================== LISTINGS ====================

@app.get("/listings")
def get_listings():
    if not container:
        return []
    try:
        query = "SELECT * FROM c WHERE c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        return items
    except Exception as e:
        logger.error(f"Error: {e}")
        return []

@app.get("/listings/my")
def get_my_listings(email: str = Depends(get_user_from_token)):
    if not container:
        return []
    try:
        query = "SELECT * FROM c WHERE c.type = 'listing' AND c.seller = @email"
        items = list(container.query_items(
            query=query,
            parameters=[{"name": "@email", "value": email}],
            enable_cross_partition_query=True
        ))
        return items
    except Exception as e:
        logger.error(f"Error: {e}")
        return []

@app.post("/listings")
def create_listing(listing: ListingCreate, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        listing_id = str(uuid.uuid4())
        doc = {
            "id": listing_id,
            "roomId": listing_id,  # Partition key for Cosmos DB
            "type": "listing",
            "title": listing.title,
            "category": listing.category or "",
            "description": listing.description or "",
            "price": float(listing.price),
            "seller": email,
            "status": "active",
            "visibility": listing.visibility or "public",
            "createdAt": datetime.utcnow().isoformat()
        }
        container.create_item(doc)
        logger.info(f"Created listing {listing_id}")
        return doc
    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(500, str(e))

@app.put("/listings/{listing_id}")
def update_listing(listing_id: str, updates: ListingUpdate, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        query = f"SELECT * FROM c WHERE c.id = '{listing_id}' AND c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        
        if not items:
            raise HTTPException(404, "Listing not found")
        
        listing = items[0]
        
        if listing.get("seller") != email:
            raise HTTPException(403, "You can only edit your own listings")
        
        if updates.title is not None:
            listing["title"] = updates.title
        if updates.category is not None:
            listing["category"] = updates.category
        if updates.description is not None:
            listing["description"] = updates.description
        if updates.price is not None:
            listing["price"] = float(updates.price)
        if updates.visibility is not None:
            listing["visibility"] = updates.visibility
        
        listing["updatedAt"] = datetime.utcnow().isoformat()
        
        container.replace_item(item=listing["id"], body=listing)
        logger.info(f"Updated listing {listing_id}")
        return listing
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(500, str(e))

@app.delete("/listings/{listing_id}")
def delete_listing(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        # Get existing listing first
        query = f"SELECT * FROM c WHERE c.id = '{listing_id}' AND c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        
        if not items:
            raise HTTPException(404, "Listing not found")
        
        listing = items[0]
        
        # Check ownership
        if listing.get("seller") != email:
            raise HTTPException(403, "You can only delete your own listings")
        
        # Delete using roomId as partition key (Cosmos DB requirement)
        partition_key = listing.get("roomId", listing_id)
        container.delete_item(item=listing_id, partition_key=partition_key)
        logger.info(f"Deleted listing {listing_id}")
        return {"status": "deleted", "id": listing_id}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Delete error: {e}")
        raise HTTPException(500, f"Delete failed: {str(e)}")

@app.post("/listings/{listing_id}/buy")
def buy_listing(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        # Get the listing
        query = f"SELECT * FROM c WHERE c.id = '{listing_id}' AND c.type = 'listing'"
        items = list(container.query_items(query=query, enable_cross_partition_query=True))
        
        if not items:
            raise HTTPException(404, "Listing not found")
        
        listing = items[0]
        
        # Check if already sold
        if listing.get("status") == "sold":
            raise HTTPException(400, "This item has already been sold")
        
        # Check if trying to buy own listing
        if listing.get("seller") == email:
            raise HTTPException(400, "You cannot buy your own listing")
        
        # Update listing to sold
        listing["status"] = "sold"
        listing["buyer"] = email
        listing["soldAt"] = datetime.utcnow().isoformat()
        listing["updatedAt"] = datetime.utcnow().isoformat()
        
        container.replace_item(item=listing["id"], body=listing)
        
        # Create automated message to seller
        message_id = str(uuid.uuid4())
        message_doc = {
            "id": message_id,
            "roomId": message_id,  # Partition key
            "type": "sale_notification",
            "listingId": listing_id,
            "seller": listing.get("seller"),
            "buyer": email,
            "listingTitle": listing.get("title"),
            "price": listing.get("price"),
            "message": f"Great news! Your listing '{listing.get('title')}' has been sold to {email} for â‚¬{listing.get('price'):.2f}",
            "read": False,
            "createdAt": datetime.utcnow().isoformat()
        }
        container.create_item(message_doc)
        
        logger.info(f"Listing {listing_id} sold to {email}")
        return {
            "status": "success",
            "message": "Purchase completed! The seller has been notified.",
            "listing": listing
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Buy error: {e}")
        raise HTTPException(500, f"Purchase failed: {str(e)}")

# ==================== FAVOURITES ====================

@app.get("/favourites")
def get_favourites(email: str = Depends(get_user_from_token)):
    if not container:
        return []
    try:
        query = "SELECT * FROM c WHERE c.type = 'favourite' AND c.userId = @email"
        items = list(container.query_items(
            query=query,
            parameters=[{"name": "@email", "value": email}],
            enable_cross_partition_query=True
        ))
        return [item["listingId"] for item in items]
    except Exception as e:
        logger.error(f"Error: {e}")
        return []

@app.post("/favourites/{listing_id}")
def add_favourite(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        fav_id = f"fav:{email}:{listing_id}"
        doc = {
            "id": fav_id,
            "roomId": fav_id,  # Partition key for Cosmos DB
            "type": "favourite",
            "userId": email,
            "listingId": listing_id,
            "createdAt": datetime.utcnow().isoformat()
        }
        container.upsert_item(doc)
        return {"status": "added"}
    except Exception as e:
        logger.error(f"Error: {e}")
        raise HTTPException(500, str(e))

@app.delete("/favourites/{listing_id}")
def remove_favourite(listing_id: str, email: str = Depends(get_user_from_token)):
    if not container:
        raise HTTPException(500, "Database not configured")
    try:
        fav_id = f"fav:{email}:{listing_id}"
        # Use fav_id as partition key since roomId = fav_id
        container.delete_item(item=fav_id, partition_key=fav_id)
        return {"status": "removed"}
    except Exception as e:
        logger.error(f"Error removing favourite: {e}")
        return {"status": "removed"}

@app.get("/healthz")
def health():
    return {"status": "healthy", "service": "listings-svc"}

@app.get("/")
def root():
    return {"service": "listings-svc"}
